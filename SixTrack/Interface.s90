+dk ffinterface
+if ffield
!! ---------------------------------------------------------------------------
!!      Interface with SixTrack
!! ---------------------------------------------------------------------------
!!      workChoise    0  - Import config file
!!                    1  - Import data file
!!                    4  - Preparation of AQx and AQy
!!                    2  - Symplectic integration
!!                    11 - Test import data file
!!                    12 - Print some particle information
!!                    6  - Free all the memory
!!                    3  - Allocate table for particle out of boundary
subroutine ffInterface (workChoise, currQuad, ffi, ffj, ffn)
   implicit none
   
   ! Definition of the ffTable type
   ! -------------------------------------------------------------------------
   type ffTable
     integer :: n,m,s                                                      ! Max exposant for x and y, Number of point in z
     integer :: lx,ly,lz                                                   ! Number of coef per step
     integer(kind=2),dimension(:,:,:),allocatable :: ij_TAx,ij_TAy,ij_TAz  ! Table of indices ij for Ax, Ay and Az
     double precision :: dz, norm, Lgth                                    ! Step size in z and normalization
     double precision,dimension(:,:),allocatable :: TAx,TAy,TAz            ! Table of coefficients for Ax, Ay and Az
     double precision,dimension(:,:,:),allocatable :: AQx,AQy              ! AntiQuad matrix
     double precision,dimension(:),allocatable :: Tdpsv                    ! dpsv value for AQ-case
     double precision,dimension(:,:,:),allocatable :: TAQx,TAQy            ! Table of AntiQuad matrix in function of Delta
!     logical,dimension(:),allocatable :: checkAQ
   end type ffTable

   ! Espace commun de SixTrack 
   ! -------------------------------------------------------------------------
+ca parpro   

+ca parnum
   
+ca commonmn

+ca common

!   <<<<<<<<<<<<<< test 07-03-2018
+ca commonm1
!   <<<<<<<<<<<<<< test 07-03-2018

+ca commontr

   ! Initialisation de l'espace commun
   ! -------------------------------------------------------------------------
+ca ffieldcommon

+ca ffieldcommon1

   ! Initialization physic parameters
   ! -------------------------------------------------------------------------
!!$   double precision :: Eproton, Etot, gamma0, beta0, p0, clight, norm !, e0
   double precision :: Etot, gamma0, beta0, p0, norm !, e0
!!$   parameter (clight=299792458.)                 ! Speed of light [m/s]
!!$   parameter (Eproton=9.382720134258239e2)       ! Mass proton [MeV] 
!   parameter (e0=1.60217653e-19)                   ! Energy of ref
   parameter (Etot=0.0d0*pmap+7.0d0*c1e6)           ! Total Energy of the system [MeV]
   parameter (gamma0=Etot/pmap)                     ! Ratio total energy and rest mass energy for the proton
   parameter (beta0=sqrt(1.0d0-1.0d0/gamma0/gamma0))! Parameter beta0
   parameter (p0=beta0*Etot*c1e6/clight)            ! Reference momentum [eV/c] 
   !parameter (p0=7.e12)
   

   ! Function parameters
   ! -------------------------------------------------------------------------
   integer,intent(in) :: workChoise, ffj, ffi, ffn
   integer, dimension(2),intent(in) :: currQuad 
   integer :: itDltmax, itDltmin, itDltmid, itDlt 


   ! Static variables
   ! -------------------------------------------------------------------------
   integer, save :: nbDlt = 0
   logical, allocatable, dimension(:), save :: ffImported     ! Static matrix one if the correspond file is already imported
   type(ffTable), allocatable, dimension(:), save :: ffTA     ! Static vector containing all the data
   integer, allocatable, dimension(:,:,:,:), save :: ffloss   ! Static matrix 
   logical, allocatable, dimension(:,:), save :: ffnotIN      ! Static matrix 
   logical, save :: firstTime = .true.                        ! Static variable that check config's file was found
   logical, save :: firstTime2 = .true.                       ! Static variable that check allocation table particle with (x*x+y+y)>r*r
   

   ! Useful variables
   ! -------------------------------------------------------------------------
   integer :: i, j, k, dataindex, sum_loss_in, sum_loss_out
   logical :: OKRead


   ! Variables that will be eliminated
   ! -------------------------------------------------------------------------
   double precision :: x, px, y, py, zb, delta, gam0, betabeta0, sigma_s
   double precision :: Ldpsv1,Ldpsv2, LoutQ
   double precision :: stracki
   character(len=512) :: inex


   ! Definition of the interface
   ! -------------------------------------------------------------------------
   interface
      subroutine CreateVectCoef(FileName,n,m,s,dz,Lgth,lx,ij_Ax,TAx,ly,ij_Ay,TAy,lz,ij_Az,TAz,norm,OKRead)
         character(len=*) :: FileName
         logical OKRead
         integer :: n,m,s
         integer :: lx,ly,lz
         integer(kind=2), dimension (:, :, :) :: ij_Ax,ij_Ay,ij_Az
         double precision :: dz,norm,Lgth
         double precision, dimension (:, :) :: TAx,TAy,TAz
      end subroutine

      subroutine fftest(n,m,s,dz,Lgth,lx,ij_TAx,TAx,ly,ij_TAy,TAy,lz,ij_TAz,TAz,norm)
         integer :: n,m,s
         integer :: lx,ly,lz
         integer(kind=2), dimension (:, :, :),allocatable :: ij_TAx,ij_TAy,ij_TAz
         double precision :: dz,norm,Lgth
         double precision, dimension (:,:),allocatable :: TAx,TAy,TAz
      end subroutine
   end interface 


   ! ??????????????????????
   ! -------------------------------------------------------------------------
   if (.not.firstTime) then
      dataindex = ffQ2File(currQuad(1), currQuad(2))
   
   else
      ffReady = .false.
      
   endif
   

   ! 0 : Import the configuration file
   ! -------------------------------------------------------------------------
   if (workChoise == 0) then
     
      if (.not.firstTime) then
         write(*,*) 'FringeField ERROR: The config file was already imported'
         return
      endif      
      call ReadconfigFile
      
      if (ffReady .eqv. .true.) then
         allocate(ffTA(1:ffNLFile))
         allocate(ffImported(1:ffNLFile))
         ffImported = .false.
         firstTime = .false.
         write (*,*) 'FringeField      : Config file imported '
         
      else
         write (*,*) 'FringeField      : Config file NOT imported'
         
      endif

   ! 1 : Import data files
   ! -------------------------------------------------------------------------
   else if ((workChoise == 1).and.(.not.firstTime)) then
      if (ffImported(dataindex)) then
         write(*,*) "FringeField      : ", TRIM(ADJUSTL(ffFNames(dataindex)))," Already imported!"
      else
         
         ffTA(:)%norm = 1.0d0/p0
         call CreateVectCoef(ffFNames(dataindex),   &
                             ffTA(dataindex)%n,     &
                             ffTA(dataindex)%m,     &
                             ffTA(dataindex)%s,     &
                             ffTA(dataindex)%dz,    &
                             ffTA(dataindex)%Lgth,  &
                             ffTA(dataindex)%lx,    &
                             ffTA(dataindex)%ij_TAx,&
                             ffTA(dataindex)%TAx,   &
                             ffTA(dataindex)%ly,    &
                             ffTA(dataindex)%ij_TAy,&
                             ffTA(dataindex)%TAy,   &
                             ffTA(dataindex)%lz,    &
                             ffTA(dataindex)%ij_TAz,&
                             ffTA(dataindex)%TAz,   &
                             ffTA(dataindex)%norm,  &
                                         OKRead)
         if (.not.OKRead) then
            write(*,*) "FringeField ERROR : I couldn't read this file ",  TRIM(ADJUSTL(ffFNames(dataindex)))

         else
            ffImported(dataindex) = .true.
            
            
            ! Allocate memmory for AQ
            Allocate(ffTA(dataindex)%AQx(1:2,1:2,1:npart),ffTA(dataindex)%AQy(1:2,1:2,1:npart))
            do j=1,npart
              ffTA(dataindex)%AQx(1,1,j)=0;              ffTA(dataindex)%AQx(1,2,j)=0;
              ffTA(dataindex)%AQx(2,1,j)=0;              ffTA(dataindex)%AQx(2,2,j)=0;
              ffTA(dataindex)%AQy(1,1,j)=0;              ffTA(dataindex)%AQy(1,2,j)=0;
              ffTA(dataindex)%AQy(2,1,j)=0;              ffTA(dataindex)%AQy(2,2,j)=0;
            enddo
            
            
            
            if (abs(ffTA(dataindex)%Lgth - ffParam(dataindex,6)) > 1E-12) then
               write(*,*) "FringeField WARNING: The length in the Config file and computed are different: ", &
                          ffParam(dataindex,6), " != ", ffTA(dataindex)%Lgth
               write(*,*) "                     We use the computed one!"
            endif
 
            write (*,*) "FringeField      : ",  TRIM(ADJUSTL(ffFNames(dataindex))) , " imported! "
         endif
      endif

   ! 2 : Symplectic routine
   ! -------------------------------------------------------------------------
   else if ((workChoise == 2).and.(.not.firstTime)) then
      if (.not.ffImported(dataindex)) then
         write (*, *) 'FringeField ERROR: The data in',  TRIM(ADJUSTL(ffFNames(dataindex))) ,'is not imported'

      else
         ! Check fine not empty
         if (ffTA(dataindex)%s<3) then
            return
         endif
         
         ! Change to Symp referenciale
         x = ((xv(1,ffj)-xsiv(1,ffi))*tiltc(ffi) + (xv(2,ffj)-zsiv(1,ffi))*tilts(ffi))*c1m3! mm -> m
         y = ((xv(2,ffj)-zsiv(1,ffi))*tiltc(ffi) - (xv(1,ffj)-xsiv(1,ffi))*tilts(ffi))*c1m3! mm -> m
         px= ((yv(1,ffj)            )*tiltc(ffi) + (yv(2,ffj)            )*tilts(ffi))*c1m3*(1.0d0+dpsv(ffj))
         py= ((yv(2,ffj)            )*tiltc(ffi) - (yv(1,ffj)            )*tilts(ffi))*c1m3*(1.0d0+dpsv(ffj))
         
         
         ! Selection of the particle that are only in the radius (r = 0.08m)
         if (((currQuad(2)==1).and.(x*x+y*y>6.4d-3)).or.             &
             ((currQuad(2)==2).and.(ffnotIN(nlostp(ffj),currQuad(1)))).or.       &
             (pstop(nlostp(ffj)))) then
         
            if (firstTime2) then
              write (*, *) "FringeField ERROR: The table for losses paticles wasn't allocated!"

            else
              ffloss(nlostp(ffj),ffn,currQuad(1),currQuad(2))=1 
              if (currQuad(2)==1) then
                ffnotIN(nlostp(ffj),currQuad(1)) = .true.
              else
                ffnotIN(nlostp(ffj),currQuad(1)) = .false.
              endif

            endif
         
	 ! Symplectic routine
         else
           !   - 
           delta    = dpsv(ffj);
           gam0     = gamma0;
           zb       = 0;
           sigma_s  = 0;
           betabeta0= ejfv(ffj)/ejv(ffj);
           betabeta0= betabeta0*betabeta0*rvv(ffj);
           LoutQ    = (ffTA(dataindex)%Lgth-ffParam(dataindex,2))
           Ldpsv1   = LoutQ*oidpsv(ffj);
           Ldpsv2   = oidpsv(ffj)*oidpsv(ffj);

           if (currQuad(2)==1) inex = "IN"
           if (currQuad(2)==2) inex = "OUT"

! <<<<<<<<<<<<<<<<<<<<<< Debug
!     if (ffj==1) then
!     write(*,*) "193 391 tsttr1 ", ffi, ffn, 1, nlostp(1), x, px, y,py, dpsv(1), dpd(1),&
!         oidpsv(1)
!     endif
! <<<<<<<<<<<<<<<<<<<<<< Debug


  	   !   - Repositionnement initial
  	   if ((inex=="IN").or.(inex=="OUT_O")) then
             !            * IN (enter) ---------> Drift
!             call AntiDriftAntiQuad(x,px,y,py, ffParam(dataindex,1),ffTA(dataindex)%Lgth,    &
!                      ffParam(dataindex,2),ffParam(dataindex,3), ffParam(dataindex,4),       &
!                      ffParam(dataindex,5),'D',oidpsv(ffj)) !,1.0d0/(1.0d0+delta))

             x=x-(ffTA(dataindex)%Lgth-ffParam(dataindex,2))*oidpsv(ffj)*px;
             y=y-(ffTA(dataindex)%Lgth-ffParam(dataindex,2))*oidpsv(ffj)*py;
!             sigma_s=sigma_s-(ffTA(dataindex)%Lgth-ffParam(dataindex,2))*oidpsv(ffj)*py;

!             x=x-Ldpsv1*px;
!             y=y-Ldpsv1*py;
!             sigma_s=sigma_s-Ldpsv2*(1.0d0-betabeta0*(1.0d0-(px*px+py*py)*Ldpsv2));

             
   	   elseif (inex=="OUT") then
             !            * IN (enter) ---------> Quad
!             call AntiDriftAntiQuad(x,px,y,py, ffParam(dataindex,1),ffTA(dataindex)%Lgth,    &
!                      ffParam(dataindex,2),ffParam(dataindex,3),ffParam(dataindex,4),        &
!                      ffParam(dataindex,5),'Q',oidpsv(ffj)) !,1.0d0/(1.0d0+delta))


             !            * IN (enter) ---------> Drift (1)
             x=x+(ffTA(dataindex)%Lgth-ffParam(dataindex,2))*oidpsv(ffj)*px;
             y=y+(ffTA(dataindex)%Lgth-ffParam(dataindex,2))*oidpsv(ffj)*py;
             
!             x=x+Ldpsv1*px;
!             y=y+Ldpsv1*py;
!             sigma_s=sigma_s-ffParam(dataindex,2)*(1.0d0-betabeta0*(1.0d0-(px*px+py*py)*Ldpsv2));


             
             !            * IN (enter) ---------> Quad (2)
             if (nbDlt<1) then                ! Case Delta to small
	       ! Generate the anti-quad
	       call GenerateAntiQuad(oidpsv(ffj), &
	                         ffTA(dataindex)%n,                   &
	                         ffTA(dataindex)%m,                   &
	                         ffTA(dataindex)%s,                   &
	                         ffTA(dataindex)%dz,                  &
	                         ffTA(dataindex)%lz,                  &
	                         ffTA(dataindex)%ij_TAz,              &
	                         ffTA(dataindex)%TAz,inex,            &
	                         ffTA(dataindex)%AQx(1,1,nlostp(ffj)),&
	                         ffTA(dataindex)%AQx(1,2,nlostp(ffj)),&
	                         ffTA(dataindex)%AQx(2,1,nlostp(ffj)),&
	                         ffTA(dataindex)%AQx(2,2,nlostp(ffj)),&
	                         ffTA(dataindex)%AQy(1,1,nlostp(ffj)),&
	                         ffTA(dataindex)%AQy(1,2,nlostp(ffj)),&
	                         ffTA(dataindex)%AQy(2,1,nlostp(ffj)),&
	                         ffTA(dataindex)%AQy(2,2,nlostp(ffj)))

               ! New AntiQuad routine
               call ComputeAntiQuad(x,px,y,py,                      &
                                 ffTA(dataindex)%AQx(1,1,nlostp(ffj)),&
                                 ffTA(dataindex)%AQx(1,2,nlostp(ffj)),&
                                 ffTA(dataindex)%AQx(2,1,nlostp(ffj)),&
                                 ffTA(dataindex)%AQx(2,2,nlostp(ffj)),&
                                 ffTA(dataindex)%AQy(1,1,nlostp(ffj)),&
	                         ffTA(dataindex)%AQy(1,2,nlostp(ffj)),&
	                         ffTA(dataindex)%AQy(2,1,nlostp(ffj)),&
	                         ffTA(dataindex)%AQy(2,2,nlostp(ffj)))

                                              ! Case Delta bigger than anticipate
             elseif (abs(dpsv(ffj))>ffTA(dataindex)%Tdpsv(nbDlt)+c1m6) then
               ! Check the maximum delta
               delta=-1.0d0
               do j=1,npart
                 if (delta<abs(dpsv(j))) then
                   delta=abs(dpsv(j))
                 endif
               enddo
               nbDlt=ceiling(abs( 2.0d0*(delta)*c1e6 ))
               
               ! Check the maximum delta
               do i=1,ffNLFile
                 if (ffImported(i) .eqv. .true.) then
                   Deallocate(ffTA(i)%TAQx,ffTA(i)%TAQy,ffTA(i)%Tdpsv)
                   Allocate(ffTA(i)%TAQx(1:2,1:2,1:nbDlt),ffTA(i)%TAQy(1:2,1:2,1:nbDlt),  &
                            ffTA(i)%Tdpsv(1:nbDlt))
          
                   
                   if (nbDlt > 1) then
                     do k=1,nbDlt
                       ffTA(i)%TAQx(1,1,k)=0;              ffTA(i)%TAQx(1,2,k)=0;
                       ffTA(i)%TAQx(2,1,k)=0;              ffTA(i)%TAQx(2,2,k)=0;
                       ffTA(i)%TAQy(1,1,k)=0;              ffTA(i)%TAQy(1,2,k)=0;
                       ffTA(i)%TAQy(2,1,k)=0;              ffTA(i)%TAQy(2,2,k)=0;
           
                       ffTA(i)%Tdpsv(k)=(2.0d0*(k-1)/(nbDlt-1)- 1.0d0)*delta
                           
                       call GenerateAntiQuad(1.0d0/(1.0d0+ffTA(i)%Tdpsv(k)), &
                                             ffTA(i)%n,                    &
                                             ffTA(i)%m,                    &
                                             ffTA(i)%s,                    &
                                             ffTA(i)%dz,                   &
                                             ffTA(i)%lz,                   &
                                             ffTA(i)%ij_TAz,               &
                                             ffTA(i)%TAz,inex,             &
                                             ffTA(i)%TAQx(1,1,k),&
                                             ffTA(i)%TAQx(1,2,k),&
                                             ffTA(i)%TAQx(2,1,k),&
                                             ffTA(i)%TAQx(2,2,k),&
                                             ffTA(i)%TAQy(1,1,k),&
                                             ffTA(i)%TAQy(1,2,k),&
                                             ffTA(i)%TAQy(2,1,k),&
                                             ffTA(i)%TAQy(2,2,k))
                     enddo
                   else
                     k=1
                     ffTA(i)%TAQx(1,1,k)=0;              ffTA(i)%TAQx(1,2,k)=0;
                     ffTA(i)%TAQx(2,1,k)=0;              ffTA(i)%TAQx(2,2,k)=0;
                     ffTA(i)%TAQy(1,1,k)=0;              ffTA(i)%TAQy(1,2,k)=0;
                     ffTA(i)%TAQy(2,1,k)=0;              ffTA(i)%TAQy(2,2,k)=0;
           
                     ffTA(i)%Tdpsv(k)=delta
                         
                     call GenerateAntiQuad(1.0d0/(1.0d0+ffTA(i)%Tdpsv(k)), &
                                           ffTA(i)%n,                    &
                                           ffTA(i)%m,                    &
                                           ffTA(i)%s,                    &
                                           ffTA(i)%dz,                   &
                                           ffTA(i)%lz,                   &
                                           ffTA(i)%ij_TAz,               &
                                           ffTA(i)%TAz,inex,             &
                                           ffTA(i)%TAQx(1,1,k),&
                                           ffTA(i)%TAQx(1,2,k),&
                                           ffTA(i)%TAQx(2,1,k),&
                                           ffTA(i)%TAQx(2,2,k),&
                                           ffTA(i)%TAQy(1,1,k),&
                                           ffTA(i)%TAQy(1,2,k),&
                                           ffTA(i)%TAQy(2,1,k),&
                                           ffTA(i)%TAQy(2,2,k))
                   endif
                 endif
               enddo

               ! Find the AQ matrix for the right dpsv
               itDlt=0
               do k=1,nbDlt
                 if (abs(dpsv(ffj)-ffTA(dataindex)%Tdpsv(k))<c1m6) then
                   itDlt=k
                 elseif ((abs(dpsv(ffj)-ffTA(dataindex)%Tdpsv(k))==c1m6).and.(itDlt==0)) then
                   itDlt=k
                 endif
               enddo
               
               ! New AntiQuad routine
               call ComputeAntiQuad(x,px,y,py,                 &
                               ffTA(dataindex)%TAQx(1,1,itDlt),&
                               ffTA(dataindex)%TAQx(1,2,itDlt),&
                               ffTA(dataindex)%TAQx(2,1,itDlt),&
                               ffTA(dataindex)%TAQx(2,2,itDlt),&
                               ffTA(dataindex)%TAQy(1,1,itDlt),&
                               ffTA(dataindex)%TAQy(1,2,itDlt),&
                               ffTA(dataindex)%TAQy(2,1,itDlt),&
                               ffTA(dataindex)%TAQy(2,2,itDlt))

                                              ! Case Delta within anticipated domain
             else
               ! Find the AQ matrix for the right dpsv
               itDlt=0
               do k=1,nbDlt
                 if (abs(dpsv(ffj)-ffTA(dataindex)%Tdpsv(k))<c1m6) then
                   itDlt=k
                 elseif ((abs(dpsv(ffj)-ffTA(dataindex)%Tdpsv(k))==c1m6).and.(itDlt==0)) then
                   itDlt=k
                 endif
               enddo
               
               ! New AntiQuad routine
               call ComputeAntiQuad(x,px,y,py,                 &
                               ffTA(dataindex)%TAQx(1,1,itDlt),&
                               ffTA(dataindex)%TAQx(1,2,itDlt),&
                               ffTA(dataindex)%TAQx(2,1,itDlt),&
                               ffTA(dataindex)%TAQx(2,2,itDlt),&
                               ffTA(dataindex)%TAQy(1,1,itDlt),&
                               ffTA(dataindex)%TAQy(1,2,itDlt),&
                               ffTA(dataindex)%TAQy(2,1,itDlt),&
                               ffTA(dataindex)%TAQy(2,2,itDlt))

             endif
   	   endif

! <<<<<<<<<<<<<<<<<<<<<< Debug
!     if (ffj==1) then
!     write(*,*) "193 391 tsttr2 ", ffi, ffn, 1, nlostp(1), x, px, y,py, dpsv(1), dpd(1),&
!         oidpsv(1)
!     endif
! <<<<<<<<<<<<<<<<<<<<<< Debug


 	   !   - Compute Fringe Field using asymplectic Map (Lie2)
           call SympIntegrator(x,px,y,py,zb,oidpsv(ffj), &
                             ffTA(dataindex)%n,       &
                             ffTA(dataindex)%m,       &
                             ffTA(dataindex)%s,       &
                             ffTA(dataindex)%dz,      &
                             ffTA(dataindex)%lx,      &
                             ffTA(dataindex)%ij_TAx,  &
                             ffTA(dataindex)%TAx,     &
                             ffTA(dataindex)%ly,      &
                             ffTA(dataindex)%ij_TAy,  &
                             ffTA(dataindex)%TAy,     & 
                             ffTA(dataindex)%lz,      &
                             ffTA(dataindex)%ij_TAz,  &
                             ffTA(dataindex)%TAz,     &
                             inex)

! <<<<<<<<<<<<<<<<<<<<<< Debug
!     if (ffj==1) then
!     write(*,*) "193 391 tsttr3 ", ffi, ffn, 1, nlostp(1), x, px, y,py, dpsv(1), dpd(1),&
!         oidpsv(1)
!     endif
! <<<<<<<<<<<<<<<<<<<<<< Debug


!           sigma_s=sigma_s + ffTA(dataindex)%Lgth + zb*betabeta0


  	   !   - Repositionnement Final
   	   if ((inex=="IN").or.(inex=="OUT_O")) then
             ! First AntiQuad routine
!             call AntiDriftAntiQuad(x,px,y,py, ffParam(dataindex,1),ffTA(dataindex)%Lgth,    &
!                      ffParam(dataindex,2),ffParam(dataindex,3),ffParam(dataindex,4),        &
!                      ffParam(dataindex,5),'Q',oidpsv(ffj)) !,1.0d0/(1.0d0+delta))

!             sigma_s=sigma_s-ffParam(dataindex,2)*(1.0d0-betabeta0*(1.0d0-(px*px+py*py)*Ldpsv2));

             if (nbDlt<1) then
	       ! Generate the anti-quad
	       call GenerateAntiQuad(oidpsv(ffj), &
	                         ffTA(dataindex)%n,                   &
	                         ffTA(dataindex)%m,                   &
	                         ffTA(dataindex)%s,                   &
	                         ffTA(dataindex)%dz,                  &
	                         ffTA(dataindex)%lz,                  &
	                         ffTA(dataindex)%ij_TAz,              &
	                         ffTA(dataindex)%TAz,inex,            &
	                         ffTA(dataindex)%AQx(1,1,nlostp(ffj)),&
	                         ffTA(dataindex)%AQx(1,2,nlostp(ffj)),&
	                         ffTA(dataindex)%AQx(2,1,nlostp(ffj)),&
	                         ffTA(dataindex)%AQx(2,2,nlostp(ffj)),&
	                         ffTA(dataindex)%AQy(1,1,nlostp(ffj)),&
	                         ffTA(dataindex)%AQy(1,2,nlostp(ffj)),&
	                         ffTA(dataindex)%AQy(2,1,nlostp(ffj)),&
	                         ffTA(dataindex)%AQy(2,2,nlostp(ffj)))

               ! New AntiQuad routine
               call ComputeAntiQuad(x,px,y,py,                      &
                                 ffTA(dataindex)%AQx(1,1,nlostp(ffj)),&
                                 ffTA(dataindex)%AQx(1,2,nlostp(ffj)),&
                                 ffTA(dataindex)%AQx(2,1,nlostp(ffj)),&
                                 ffTA(dataindex)%AQx(2,2,nlostp(ffj)),&
                                 ffTA(dataindex)%AQy(1,1,nlostp(ffj)),&
	                         ffTA(dataindex)%AQy(1,2,nlostp(ffj)),&
	                         ffTA(dataindex)%AQy(2,1,nlostp(ffj)),&
	                         ffTA(dataindex)%AQy(2,2,nlostp(ffj)))

! <<<<<<<<<<<<<<<<<<<<<< Debug
!     if (ffj==1) then
!     write(*,*) "193 391 tsttr4       1"
!     endif
! <<<<<<<<<<<<<<<<<<<<<< Debug


                                              ! Case Delta bigger than anticipate
             elseif (abs(dpsv(ffj))>ffTA(dataindex)%Tdpsv(nbDlt)+c1m6) then
               ! Check the maximum delta
               delta=-1.0d0
               do j=1,npart
                 if (delta<abs(dpsv(j))) then
                   delta=abs(dpsv(j))
                 endif
               enddo
               nbDlt=ceiling(abs( 2.0d0*(delta)*c1e6 ))
               
               ! Check the maximum delta
               do i=1,ffNLFile
                 if (ffImported(i) .eqv. .true.) then
                   Deallocate(ffTA(i)%TAQx,ffTA(i)%TAQy,ffTA(i)%Tdpsv)
                   Allocate(ffTA(i)%TAQx(1:2,1:2,1:nbDlt),ffTA(i)%TAQy(1:2,1:2,1:nbDlt),  &
                            ffTA(i)%Tdpsv(1:nbDlt))
                   
                   if (nbDlt > 1) then
                     do k=1,nbDlt
                       ffTA(i)%TAQx(1,1,k)=0;              ffTA(i)%TAQx(1,2,k)=0;
                       ffTA(i)%TAQx(2,1,k)=0;              ffTA(i)%TAQx(2,2,k)=0;
                       ffTA(i)%TAQy(1,1,k)=0;              ffTA(i)%TAQy(1,2,k)=0;
                       ffTA(i)%TAQy(2,1,k)=0;              ffTA(i)%TAQy(2,2,k)=0;
           
                       ffTA(i)%Tdpsv(k)=(2.0d0*(k-1)/(nbDlt-1)- 1.0d0)*delta
                           
                       call GenerateAntiQuad(1.0d0/(1.0d0+ffTA(i)%Tdpsv(k)), &
                                             ffTA(i)%n,                    &
                                             ffTA(i)%m,                    &
                                             ffTA(i)%s,                    &
                                             ffTA(i)%dz,                   &
                                             ffTA(i)%lz,                   &
                                             ffTA(i)%ij_TAz,               &
                                             ffTA(i)%TAz,inex,             &
                                             ffTA(i)%TAQx(1,1,k),&
                                             ffTA(i)%TAQx(1,2,k),&
                                             ffTA(i)%TAQx(2,1,k),&
                                             ffTA(i)%TAQx(2,2,k),&
                                             ffTA(i)%TAQy(1,1,k),&
                                             ffTA(i)%TAQy(1,2,k),&
                                             ffTA(i)%TAQy(2,1,k),&
                                             ffTA(i)%TAQy(2,2,k))
                     enddo
                   else
                     k=1
                     ffTA(i)%TAQx(1,1,k)=0;              ffTA(i)%TAQx(1,2,k)=0;
                     ffTA(i)%TAQx(2,1,k)=0;              ffTA(i)%TAQx(2,2,k)=0;
                     ffTA(i)%TAQy(1,1,k)=0;              ffTA(i)%TAQy(1,2,k)=0;
                     ffTA(i)%TAQy(2,1,k)=0;              ffTA(i)%TAQy(2,2,k)=0;
           
                     ffTA(i)%Tdpsv(k)=delta
                         
                     call GenerateAntiQuad(1.0d0/(1.0d0+ffTA(i)%Tdpsv(k)), &
                                           ffTA(i)%n,                    &
                                           ffTA(i)%m,                    &
                                           ffTA(i)%s,                    &
                                           ffTA(i)%dz,                   &
                                           ffTA(i)%lz,                   &
                                           ffTA(i)%ij_TAz,               &
                                           ffTA(i)%TAz,inex,             &
                                           ffTA(i)%TAQx(1,1,k),&
                                           ffTA(i)%TAQx(1,2,k),&
                                           ffTA(i)%TAQx(2,1,k),&
                                           ffTA(i)%TAQx(2,2,k),&
                                           ffTA(i)%TAQy(1,1,k),&
                                           ffTA(i)%TAQy(1,2,k),&
                                           ffTA(i)%TAQy(2,1,k),&
                                           ffTA(i)%TAQy(2,2,k))
                   endif
                 endif
               enddo

               ! Find the AQ matrix for the right dpsv
               itDlt=0
               do k=1,nbDlt
                 if (abs(dpsv(ffj)-ffTA(dataindex)%Tdpsv(k))<c1m6) then
                   itDlt=k
                 elseif ((abs(dpsv(ffj)-ffTA(dataindex)%Tdpsv(k))==c1m6).and.(itDlt==0)) then
                   itDlt=k
                 endif
               enddo
               
               ! New AntiQuad routine
               call ComputeAntiQuad(x,px,y,py,                 &
                               ffTA(dataindex)%TAQx(1,1,itDlt),&
                               ffTA(dataindex)%TAQx(1,2,itDlt),&
                               ffTA(dataindex)%TAQx(2,1,itDlt),&
                               ffTA(dataindex)%TAQx(2,2,itDlt),&
                               ffTA(dataindex)%TAQy(1,1,itDlt),&
                               ffTA(dataindex)%TAQy(1,2,itDlt),&
                               ffTA(dataindex)%TAQy(2,1,itDlt),&
                               ffTA(dataindex)%TAQy(2,2,itDlt))

! <<<<<<<<<<<<<<<<<<<<<< Debug
!     if (ffj==1) then
!     write(*,*) "193 391 tsttr4       2"
!     endif
! <<<<<<<<<<<<<<<<<<<<<< Debug

                                              ! Case Delta within anticipated domain
             else
               ! Find the AQ matrix for the right dpsv
               itDlt=0
               do k=1,nbDlt
                 if (abs(dpsv(ffj)-ffTA(dataindex)%Tdpsv(k))<c1m6) then
                   itDlt=k
                 elseif ((abs(dpsv(ffj)-ffTA(dataindex)%Tdpsv(k))==c1m6).and.(itDlt==0)) then
                   itDlt=k
                 endif
               enddo
               
               
               ! New AntiQuad routine
               call ComputeAntiQuad(x,px,y,py,                 &
                               ffTA(dataindex)%TAQx(1,1,itDlt),&
                               ffTA(dataindex)%TAQx(1,2,itDlt),&
                               ffTA(dataindex)%TAQx(2,1,itDlt),&
                               ffTA(dataindex)%TAQx(2,2,itDlt),&
                               ffTA(dataindex)%TAQy(1,1,itDlt),&
                               ffTA(dataindex)%TAQy(1,2,itDlt),&
                               ffTA(dataindex)%TAQy(2,1,itDlt),&
                               ffTA(dataindex)%TAQy(2,2,itDlt))

! <<<<<<<<<<<<<<<<<<<<<< Debug
!     if (ffj==1) then
!     write(*,*) "193 391 tsttr4       3   x",    ffTA(dataindex)%TAQx(1,1,itDlt),&
!                ffTA(dataindex)%TAQx(1,2,itDlt),ffTA(dataindex)%TAQx(2,1,itDlt),&
!                ffTA(dataindex)%TAQx(2,2,itDlt),"  y",ffTA(dataindex)%TAQy(1,1,itDlt),&
!                ffTA(dataindex)%TAQy(1,2,itDlt),ffTA(dataindex)%TAQy(2,1,itDlt),&
!                ffTA(dataindex)%TAQy(2,2,itDlt)
!     endif
! <<<<<<<<<<<<<<<<<<<<<< Debug
             endif
             x=x+(ffTA(dataindex)%Lgth-ffParam(dataindex,2))*oidpsv(ffj)*px;
             y=y+(ffTA(dataindex)%Lgth-ffParam(dataindex,2))*oidpsv(ffj)*py;


!             x=x+Ldpsv1*px;
!             y=y+Ldpsv1*py;
             
  	   elseif (inex=="OUT") then
!             call AntiDriftAntiQuad(x,px,y,py, ffParam(dataindex,1),ffTA(dataindex)%Lgth,    &
!                      ffParam(dataindex,2),ffParam(dataindex,3),ffParam(dataindex,4),        &
!                      ffParam(dataindex,5),'D',oidpsv(ffj)) !,1.0d0/(1.0d0+delta))

             x=x-(ffTA(dataindex)%Lgth-ffParam(dataindex,2))*oidpsv(ffj)*px;
             y=y-(ffTA(dataindex)%Lgth-ffParam(dataindex,2))*oidpsv(ffj)*py;

! <<<<<<<<<<<<<<<<<<<<<< Debug
!     if (ffj==1) then
!     write(*,*) "193 391 tsttr4       4"
!     endif
! <<<<<<<<<<<<<<<<<<<<<< Debug

!             x=x-Ldpsv1*px;
!             y=y-Ldpsv1*py;
!             sigma_s=sigma_s-ffParam(dataindex,2)*(1.0d0-betabeta0*(1.0d0-(px*px+py*py)*Ldpsv2));
             
   	   endif

! <<<<<<<<<<<<<<<<<<<<<< Debug
!     if (ffj==1) then
!     write(*,*) "193 391 tsttr4 ", ffi, ffn, 1, nlostp(1), x, px, y,py, dpsv(1), dpd(1),&
!         oidpsv(1)
!     endif
! <<<<<<<<<<<<<<<<<<<<<< Debug


!           sigmv(ffj)=sigmv(ffj)+sigma_s*c1e3;



           ! Change to SixTrack referenciale
           yv(1,ffj) = (tiltc(ffi)*px - tilts(ffi)*py)*c1e3*oidpsv(ffj)
           yv(2,ffj) = (tilts(ffi)*px + tiltc(ffi)*py)*c1e3*oidpsv(ffj)
           xv(1,ffj) = (tiltc(ffi)*x  - tilts(ffi)*y )*c1e3 + xsiv(1,ffi)   ! m -> mm
           xv(2,ffj) = (tilts(ffi)*x  + tiltc(ffi)*y )*c1e3 + zsiv(1,ffi)   ! m -> mm
	endif
      endif


   ! 11 : Test
   ! -------------------------------------------------------------------------
   else if ((workChoise == 11).and.(.not.firstTime)) then
      call fftest(ffTA(dataindex)%n,     &
                  ffTA(dataindex)%m,     &
                  ffTA(dataindex)%s,     &
                  ffTA(dataindex)%dz,    &
                  ffTA(dataindex)%Lgth,  & 
                  ffTA(dataindex)%lx,    &
                  ffTA(dataindex)%ij_TAx,&
                  ffTA(dataindex)%TAx,   &
                  ffTA(dataindex)%ly,    &
                  ffTA(dataindex)%ij_TAy,&
                  ffTA(dataindex)%TAy,   &
                  ffTA(dataindex)%lz,    &
                  ffTA(dataindex)%ij_TAz,&
                  ffTA(dataindex)%TAz,   &
                  ffTA(dataindex)%norm)
      ffImported(dataindex) = .true.
      write (*,*) 'workChoise == 11'


   ! 12 : Test
   ! -------------------------------------------------------------------------
   else if (workChoise == 12) then
     if (ffi == 1) then !(.false.) then !
       do j = 1,napx
!         if (.true.) then
!         if ((nlostp(j) == 1).or.(nlostp(j) == 9).or.(nlostp(j) == 10).or.            &
!             (nlostp(j) == 15).or.(nlostp(j) == 16)) then
           write(*,*) "12 21 ", ffi, ffn, j, nlostp(j), xv(1,j), yv(1,j), xv(2,j),&
                       yv(2,j), dpsv(j), dpd(j), oidpsv(j)
!         endif
       enddo
     endif

! <<<<<<<<<<<<<<<<<< Debug
!     write(*,*) "193 391 tsttrn ", ffi, ffn, 1, nlostp(1), xv(1,1), yv(1,1), xv(2,1),&
!                       yv(2,1), dpsv(1), dpd(1), oidpsv(1)
! <<<<<<<<<<<<<<<<<< Debug

   ! 3 : Allocation table for particles out of boundary
   ! -------------------------------------------------------------------------
   else if ((workChoise == 3)) then
      if (firstTime2) then
         ALLOCATE(ffloss(1:npart,1:numl,1:ffNLn,1:2),ffnotIN(1:npart,1:ffNLn))
         do i=1,npart
            do j=1,numl
               do k=1,ffNLn
                  ffloss(i,j,k,1)=0
                  ffloss(i,j,k,2)=0
               enddo
            enddo
         enddo

         do i=1,npart
            do k=1,ffNLn
               ffnotIN(i,k)=.false.
            enddo
         enddo

         firstTime2=.false.

      else
         write(*,*) 'FringeField ERROR: Allocation table for particles out of boundary already done!'
         return

      endif
   

   ! 4 : Preparation of AQx and AQy
   ! -------------------------------------------------------------------------
   else if ((workChoise == 4).and.(.not.firstTime)) then
     ! Check the maximum delta
     delta=-1.0d0
     do j=1,npart
       if (delta<abs(dpsv(j))) then
         delta=abs(dpsv(j))
       endif
     enddo
     nbDlt=ceiling(abs( 2.0d0*(delta)*c1e6 ))

! <<<<<<<<<<<<<<<<<< Debug
!     write(*,*) "193 391 tsttrn DDD ", delta,nbDlt,(2.0d0*(1-1)/(nbDlt-1)- 1.0d0)*delta
! <<<<<<<<<<<<<<<<<< Debug


     ! Check the maximum delta
     do i=1,ffNLFile
       if (ffImported(i) .eqv. .true.) then
          Allocate(ffTA(i)%TAQx(1:2,1:2,1:nbDlt),ffTA(i)%TAQy(1:2,1:2,1:nbDlt),ffTA(i)%Tdpsv(1:nbDlt))
          
          
          if (nbDlt > 1) then
            do k=1,nbDlt
              ffTA(i)%TAQx(1,1,k)=0;              ffTA(i)%TAQx(1,2,k)=0;
              ffTA(i)%TAQx(2,1,k)=0;              ffTA(i)%TAQx(2,2,k)=0;
              ffTA(i)%TAQy(1,1,k)=0;              ffTA(i)%TAQy(1,2,k)=0;
              ffTA(i)%TAQy(2,1,k)=0;              ffTA(i)%TAQy(2,2,k)=0;
           
              ffTA(i)%Tdpsv(k)=(2.0d0*(k-1)/(nbDlt-1)- 1.0d0)*delta
                           
              call GenerateAntiQuad(1.0d0/(1.0d0+ffTA(i)%Tdpsv(k)), &
                                    ffTA(i)%n,                    &
                                    ffTA(i)%m,                    &
                                    ffTA(i)%s,                    &
                                    ffTA(i)%dz,                   &
                                    ffTA(i)%lz,                   &
                                    ffTA(i)%ij_TAz,               &
                                    ffTA(i)%TAz,inex,             &
                                    ffTA(i)%TAQx(1,1,k),&
                                    ffTA(i)%TAQx(1,2,k),&
                                    ffTA(i)%TAQx(2,1,k),&
                                    ffTA(i)%TAQx(2,2,k),&
                                    ffTA(i)%TAQy(1,1,k),&
                                    ffTA(i)%TAQy(1,2,k),&
                                    ffTA(i)%TAQy(2,1,k),&
                                    ffTA(i)%TAQy(2,2,k))
             enddo
          else
            k=1
            ffTA(i)%TAQx(1,1,k)=0;              ffTA(i)%TAQx(1,2,k)=0;
            ffTA(i)%TAQx(2,1,k)=0;              ffTA(i)%TAQx(2,2,k)=0;
            ffTA(i)%TAQy(1,1,k)=0;              ffTA(i)%TAQy(1,2,k)=0;
            ffTA(i)%TAQy(2,1,k)=0;              ffTA(i)%TAQy(2,2,k)=0;
           
            ffTA(i)%Tdpsv(k)=delta
                     
            call GenerateAntiQuad(1.0d0/(1.0d0+ffTA(i)%Tdpsv(k)), &
                                  ffTA(i)%n,                    &
                                  ffTA(i)%m,                    &
                                  ffTA(i)%s,                    &
                                  ffTA(i)%dz,                   &
                                  ffTA(i)%lz,                   &
                                  ffTA(i)%ij_TAz,               &
                                  ffTA(i)%TAz,inex,             &
                                  ffTA(i)%TAQx(1,1,k),&
                                  ffTA(i)%TAQx(1,2,k),&
                                  ffTA(i)%TAQx(2,1,k),&
                                  ffTA(i)%TAQx(2,2,k),&
                                  ffTA(i)%TAQy(1,1,k),&
                                  ffTA(i)%TAQy(1,2,k),&
                                  ffTA(i)%TAQy(2,1,k),&
                                  ffTA(i)%TAQy(2,2,k))
         endif
       endif
     enddo
   
   
      
      
   ! 6 : End of the code -> free the memory
   ! -------------------------------------------------------------------------
   else if (workChoise == 6) then
      write(*,*) " "
      write(*,*) "------------------------ Fringe Field end ------------------------"


      if (.not.firstTime2) then

         if (.not.firstTime) then
            do i = 1,npart
               if (pstop(i)) then
                  write(*,*) "     * Part ",i,":    LOST!!!"
               else
                  write(*,*) "     * Part ",i,":"
               endif

               do k = 1,ffNLn
                  sum_loss_in=0
                  sum_loss_out=0
                  do j = 1,numl
                     sum_loss_in =sum_loss_in +ffloss(i,j,k,1)
                     sum_loss_out=sum_loss_out+ffloss(i,j,k,2)
                  enddo
            
                  write(*,*) "           -> ",TRIM(ffQNames(k)),": Number of period out of boundary: (in) ",&
                         &sum_loss_in," (out) ",sum_loss_out
               enddo
            enddo
         endif

         deallocate(ffloss,ffnotIN)
         firstTime2 = .true.
         write (*,*) "FringeField      : Table for particle out of boundary deallocated!"

      else
         write (*,*) "FringeField      : Table for particle out of boundary wasn't deallocated!"

      endif



      if (.not.firstTime) then
         do i = 1,ffNLFile
            if (ffImported(i)) then
               deallocate(ffTA(i)%ij_TAx, ffTA(i)%ij_TAy, ffTA(i)%ij_TAz )
               deallocate(ffTA(i)%TAx   , ffTA(i)%TAy   , ffTA(i)%TAz    )
               deallocate(ffTA(i)%AQx   , ffTA(i)%AQy   )!, ffTA(i)%checkAQ)
               if ( allocated(ffTA(i)%TAQx) ) then
                  deallocate(ffTA(i)%TAQx  , ffTA(i)%TAQy  , ffTA(i)%Tdpsv  )
               endif
            endif
         enddo
         deallocate (ffTA)
         deallocate (ffImported)
         deallocate (ffQNames, ffParam)
         ffQNames => NULL()
         ffParam => NULL()
         firstTime = .true.
         write (*,*) "FringeField      : All Fringe-Field table's deallocated!"

      else
         write (*,*) "FringeField      : All Fringe-Field table's weren't deallocated!"

      endif
   
   else
      write(*,*) 'FringeField ERROR: Not valid choise ', workChoise, ' or empty tables >> ', firstTime
      write(*,*) '                   CurQ = ',currQuad(1),currQuad(2)
      write(*,*) '                   ffQ2File = ',ffQ2File(currQuad(1),currQuad(2)),' Id Tab = ', dataindex

   endif
   
   return
end subroutine




!! ---------------------------------------------------------------------------
!!      Routine to test the code
!! ---------------------------------------------------------------------------
subroutine fftest(n,m,s,dz,Lgth,lx,ij_TAx,TAx,ly,ij_TAy,TAy,lz,ij_TAz,TAz,norm)
     integer :: n,m,s                                                       ! Maximum exposant for x and y, Number of point in z
     integer :: lx,ly,lz                                                    ! 
     integer(kind=2),dimension(:,:,:), allocatable :: ij_TAx,ij_TAy,ij_TAz  ! Table of indices ij for Ax, Ay and Az
     double precision :: dz,norm,Lgth                                       ! Step size in z and normalisation
     double precision,dimension(:,:), allocatable :: TAx,TAy,TAz            ! New table of coefficients of Ax, Ay and Az
     

     n = 3
     m = 12
     s = 12122
     dz = 0.256
     Lgth = 0.1
     lx = 223
     ly = 225
     lz = 224

     allocate(ij_TAx(1:2,1:2,1:3), ij_TAz(1:2,1:2,1:3), ij_TAy(1:2,1:2,1:3))
     allocate(TAx(1:2,1:2), TAz(1:2,1:2), TAy(1:2,1:2))

     ij_TAx(1:2,1:2,1:3) = 1
     TAx(1:2,1:2) = 2
     ij_TAy(1:2,1:2,1:3) = 3
     TAy(1:2,1:2) = 4
     ij_TAz(1:2,1:2,1:3) = 5
     TAz(1:2,1:2) = 9
     norm = 0.288
end subroutine
+ei
